// Parse adjacency matrix input
function parseAdjMatrix(input) {
    try {
        const matrix = JSON.parse(input);
        if (Array.isArray(matrix)) {
            return matrix;
        }
        return null;
    } catch (e) {
        alert("Invalid adjacency matrix format!");
        return null;
    }
}

// DFS function
function dfs(adjacencyMatrix, startNode) {
    const visited = [];
    const stack = [startNode];

    while (stack.length > 0) {
        const node = stack.pop();
        if (!visited.includes(node)) {
            visited.push(node);
            for (let neighbor = adjacencyMatrix[node].length - 1; neighbor >= 0; neighbor--) {
                if (adjacencyMatrix[node][neighbor] && !visited.includes(neighbor)) {
                    stack.push(neighbor);
                }
            }
        }
    }
    return visited;
}

// Initialize graph visualization
function visualizeGraph(adjacencyMatrix, traversalOrder) {
    const container = document.getElementById('graphContainer');
    container.innerHTML = ''; // Clear previous graph

    const nodeCount = adjacencyMatrix.length;
    const nodes = [];

    // Generate nodes
    for (let i = 0; i < nodeCount; i++) {
        nodes.push({ id: i, x: Math.random() * 400 + 50, y: Math.random() * 300 + 50 });
    }

    // Draw edges
    adjacencyMatrix.forEach((row, i) => {
        row.forEach((connected, j) => {
            if (connected && i < j) {
                // Draw line
                const line = document.createElement('div');
                line.className = 'edge';
                line.style.position = 'absolute';
                line.style.width = '2px';
                line.style.backgroundColor = '#34495e';

                const startX = nodes[i].x;
                const startY = nodes[i].y;
                const endX = nodes[j].x;
                const endY = nodes[j].y;

                const length = Math.hypot(endX - startX, endY - startY);
                const angle = Math.atan2(endY - startY, endX - startX) * (180 / Math.PI);

                line.style.top = startY + 'px';
                line.style.left = startX + 'px';
                line.style.width = length + 'px';
                line.style.transformOrigin = '0 0';
                line.style.transform = `rotate(${angle}deg)`;

                container.appendChild(line);
            }
        });
    });

    // Draw nodes
    nodes.forEach(node => {
        const circle = document.createElement('div');
        circle.className = 'node';
        circle.innerText = node.id;
        circle.style.position = 'absolute';
        circle.style.width = '30px';
        circle.style.height = '30px';
        circle.style.borderRadius = '50%';
        circle.style.backgroundColor = '#2980b9';
        circle.style.color = '#fff';
        circle.style.display = 'flex';
        circle.style.justifyContent = 'center';
        circle.style.alignItems = 'center';
        circle.style.cursor = 'pointer';
        circle.style.left = (node.x - 15) + 'px';
        circle.style.top = (node.y - 15) + 'px';
        container.appendChild(circle);
    });

    // Animate traversal
    let index = 0;
    const interval = setInterval(() => {
        if (index >= traversalOrder.length) {
            clearInterval(interval);
            return;
        }
        const nodeId = traversalOrder[index];
        const nodeElems = document.getElementsByClassName('node');
        for (let node of nodeElems) {
            if (parseInt(node.innerText) === nodeId) {
                node.style.backgroundColor = '#e74c3c'; // Visited color
            }
        }
        index++;
    }, 500);
}

// Event handlers
document.getElementById('runBtn').addEventListener('click', () => {
    const input = document.getElementById('adjMatrix').value;
    const adjacencyMatrix = parseAdjMatrix(input);
    if (!adjacencyMatrix) return;

    const startNode = parseInt(document.getElementById('startNode').value);
    if (isNaN(startNode) || startNode < 0 || startNode >= adjacencyMatrix.length) {
        alert('Invalid start node!');
        return;
    }

    const result = dfs(adjacencyMatrix, startNode);
    document.getElementById('visitedNodes').innerText = result.join(', ');
});

document.getElementById('visualizeBtn').addEventListener('click', () => {
    const input = document.getElementById('adjMatrix').value;
    const adjacencyMatrix = parseAdjMatrix(input);
    if (!adjacencyMatrix) return;

    const startNode = parseInt(document.getElementById('startNode').value);
    if (isNaN(startNode) || startNode < 0 || startNode >= adjacencyMatrix.length) {
        alert('Invalid start node!');
        return;
    }

    const traversalOrder = dfs(adjacencyMatrix, startNode);
    visualizeGraph(adjacencyMatrix, traversalOrder);
});
